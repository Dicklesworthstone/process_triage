//! Pooled FDR control across fleet hosts.
//!
//! Manages false discovery rate budgets across multiple hosts, pools e-values
//! for cross-host evidence, and implements alpha allocation strategies.
//!
//! When fleet-wide FDR exceeds the budget, all kill actions are halted until
//! the budget recovers.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Fleet-wide FDR configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FleetFdrConfig {
    /// Total FDR budget for the fleet.
    pub fleet_alpha: f64,
    /// Alpha allocation strategy.
    pub allocation: AlphaAllocation,
    /// Halt all kills if fleet FDR exceeds this threshold.
    pub halt_threshold: f64,
    /// Quarantine a host if its local FDR exceeds this.
    pub host_quarantine_threshold: f64,
    /// Rebalance interval in seconds.
    pub rebalance_interval_secs: u64,
}

impl Default for FleetFdrConfig {
    fn default() -> Self {
        Self {
            fleet_alpha: 0.05,
            allocation: AlphaAllocation::Proportional,
            halt_threshold: 0.05,
            host_quarantine_threshold: 0.15,
            rebalance_interval_secs: 3600,
        }
    }
}

/// Strategy for allocating alpha budget across hosts.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AlphaAllocation {
    /// Equal budget for each host: α/n.
    Equal,
    /// Proportional to host's process count.
    Proportional,
    /// Sequential alpha-investing across time.
    Sequential,
}

/// Per-host FDR tracking state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HostFdrState {
    /// Host identifier.
    pub host_id: String,
    /// Allocated alpha budget.
    pub budget: f64,
    /// Alpha used so far.
    pub used: f64,
    /// Number of tests performed.
    pub n_tests: u64,
    /// Number of discoveries (kills executed).
    pub n_discoveries: u64,
    /// E-values from this host's decisions.
    pub e_values: Vec<f64>,
    /// Whether this host is quarantined.
    pub quarantined: bool,
    /// Last activity timestamp.
    pub last_active: DateTime<Utc>,
    /// Process count (for proportional allocation).
    pub process_count: usize,
}

impl HostFdrState {
    pub fn new(host_id: &str) -> Self {
        Self {
            host_id: host_id.to_string(),
            budget: 0.0,
            used: 0.0,
            n_tests: 0,
            n_discoveries: 0,
            e_values: Vec::new(),
            quarantined: false,
            last_active: Utc::now(),
            process_count: 0,
        }
    }

    /// Estimated local FDR: used / max(discoveries, 1).
    pub fn estimated_fdr(&self) -> f64 {
        if self.n_discoveries == 0 {
            0.0
        } else {
            self.used / self.n_discoveries as f64
        }
    }

    /// Remaining budget.
    pub fn remaining(&self) -> f64 {
        (self.budget - self.used).max(0.0)
    }
}

/// Fleet-wide FDR coordinator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FleetFdrCoordinator {
    /// Configuration.
    pub config: FleetFdrConfig,
    /// Per-host state.
    pub hosts: HashMap<String, HostFdrState>,
    /// Whether fleet-wide halt is active.
    pub halted: bool,
    /// Last rebalance timestamp.
    pub last_rebalance: DateTime<Utc>,
    /// Fleet-wide alerts.
    pub alerts: Vec<FdrAlert>,
}

/// An alert generated by the FDR coordinator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FdrAlert {
    /// Alert type.
    pub kind: FdrAlertKind,
    /// Affected host (if applicable).
    pub host_id: Option<String>,
    /// Alert message.
    pub message: String,
    /// When the alert was generated.
    pub timestamp: DateTime<Utc>,
}

/// Types of FDR alerts.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FdrAlertKind {
    /// Fleet FDR exceeded budget; kills halted.
    FleetHalt,
    /// Host quarantined due to high local FDR.
    HostQuarantine,
    /// Budget rebalanced.
    Rebalance,
    /// Fleet halt lifted.
    HaltLifted,
}

/// Result of submitting e-values to the coordinator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubmitResult {
    /// Whether the kill is approved.
    pub approved: bool,
    /// Remaining budget for this host.
    pub remaining_budget: f64,
    /// Fleet-wide FDR estimate.
    pub fleet_fdr: f64,
    /// Reason for rejection (if not approved).
    pub rejection_reason: Option<String>,
}

/// Combined evidence from multiple hosts for the same pattern.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PooledEvidence {
    /// Pattern identifier (e.g., command signature hash).
    pub pattern_id: String,
    /// Per-host e-values.
    pub host_evidence: Vec<(String, f64)>,
    /// Combined e-value (product for independent evidence).
    pub combined_e_value: f64,
    /// Number of hosts contributing evidence.
    pub n_hosts: usize,
}

impl FleetFdrCoordinator {
    pub fn new(config: FleetFdrConfig) -> Self {
        Self {
            config,
            hosts: HashMap::new(),
            halted: false,
            last_rebalance: Utc::now(),
            alerts: Vec::new(),
        }
    }

    /// Register a host with its process count.
    pub fn register_host(&mut self, host_id: &str, process_count: usize) {
        let state = self
            .hosts
            .entry(host_id.to_string())
            .or_insert_with(|| HostFdrState::new(host_id));
        state.process_count = process_count;
        state.last_active = Utc::now();
        self.rebalance();
    }

    /// Submit an e-value for a kill decision on a host.
    ///
    /// Returns whether the kill is approved given the current budget.
    pub fn submit_e_value(&mut self, host_id: &str, e_value: f64) -> SubmitResult {
        let fleet_fdr = self.compute_fleet_fdr();

        // Check fleet halt.
        if self.halted {
            return SubmitResult {
                approved: false,
                remaining_budget: 0.0,
                fleet_fdr,
                rejection_reason: Some("Fleet-wide halt active".to_string()),
            };
        }

        // Check host exists and is not quarantined.
        let (quarantined, remaining) = match self.hosts.get(host_id) {
            Some(h) => (h.quarantined, h.remaining()),
            None => {
                return SubmitResult {
                    approved: false,
                    remaining_budget: 0.0,
                    fleet_fdr,
                    rejection_reason: Some("Host not registered".to_string()),
                };
            }
        };

        if quarantined {
            return SubmitResult {
                approved: false,
                remaining_budget: remaining,
                fleet_fdr,
                rejection_reason: Some("Host quarantined".to_string()),
            };
        }

        // p-value from e-value.
        let p_value = if e_value > 0.0 {
            (1.0 / e_value).min(1.0)
        } else {
            1.0
        };

        // Update host state.
        let host = self.hosts.get_mut(host_id).unwrap();
        host.e_values.push(e_value);
        host.n_tests += 1;
        host.last_active = Utc::now();

        if p_value <= host.remaining() {
            host.used += p_value;
            host.n_discoveries += 1;
            let host_fdr = host.estimated_fdr();
            let host_remaining = host.remaining();
            let hid = host.host_id.clone();

            // Check host quarantine.
            if host_fdr > self.config.host_quarantine_threshold {
                let host = self.hosts.get_mut(host_id).unwrap();
                host.quarantined = true;
                self.alerts.push(FdrAlert {
                    kind: FdrAlertKind::HostQuarantine,
                    host_id: Some(hid),
                    message: format!(
                        "Host {} FDR {:.4} exceeds quarantine threshold",
                        host_id, host_fdr
                    ),
                    timestamp: Utc::now(),
                });
            }

            // Re-check fleet FDR after this decision.
            let new_fleet_fdr = self.compute_fleet_fdr();
            if new_fleet_fdr > self.config.halt_threshold {
                self.halted = true;
                self.alerts.push(FdrAlert {
                    kind: FdrAlertKind::FleetHalt,
                    host_id: None,
                    message: format!(
                        "Fleet FDR {:.4} exceeds threshold {:.4}; kills halted",
                        new_fleet_fdr, self.config.halt_threshold
                    ),
                    timestamp: Utc::now(),
                });
            }

            SubmitResult {
                approved: true,
                remaining_budget: host_remaining,
                fleet_fdr: new_fleet_fdr,
                rejection_reason: None,
            }
        } else {
            let host_remaining = host.remaining();
            SubmitResult {
                approved: false,
                remaining_budget: host_remaining,
                fleet_fdr,
                rejection_reason: Some(format!(
                    "p-value {:.4} exceeds remaining budget {:.4}",
                    p_value, host_remaining
                )),
            }
        }
    }

    /// Combine evidence from multiple hosts for the same pattern.
    pub fn pool_evidence(
        &self,
        pattern_id: &str,
        host_e_values: &[(&str, f64)],
    ) -> PooledEvidence {
        // Product of e-values (valid under independence).
        let combined = host_e_values
            .iter()
            .map(|(_, e)| e.max(1e-15))
            .fold(1.0, |acc, e| acc * e);

        PooledEvidence {
            pattern_id: pattern_id.to_string(),
            host_evidence: host_e_values
                .iter()
                .map(|(h, e)| (h.to_string(), *e))
                .collect(),
            combined_e_value: combined,
            n_hosts: host_e_values.len(),
        }
    }

    /// Compute fleet-wide FDR estimate.
    pub fn compute_fleet_fdr(&self) -> f64 {
        let total_used: f64 = self.hosts.values().map(|h| h.used).sum();
        let total_discoveries: u64 = self.hosts.values().map(|h| h.n_discoveries).sum();

        if total_discoveries == 0 {
            0.0
        } else {
            total_used / total_discoveries as f64
        }
    }

    /// Rebalance alpha budgets across hosts.
    pub fn rebalance(&mut self) {
        let n_hosts = self.hosts.len();
        if n_hosts == 0 {
            return;
        }

        match self.config.allocation {
            AlphaAllocation::Equal => {
                let per_host = self.config.fleet_alpha / n_hosts as f64;
                for host in self.hosts.values_mut() {
                    host.budget = per_host;
                }
            }
            AlphaAllocation::Proportional => {
                let total_procs: usize = self.hosts.values().map(|h| h.process_count.max(1)).sum();
                for host in self.hosts.values_mut() {
                    let fraction = host.process_count.max(1) as f64 / total_procs as f64;
                    host.budget = self.config.fleet_alpha * fraction;
                }
            }
            AlphaAllocation::Sequential => {
                // Simple alpha-investing: start with equal, redistribute unused.
                let per_host = self.config.fleet_alpha / n_hosts as f64;
                let unused: f64 = self
                    .hosts
                    .values()
                    .map(|h| (per_host - h.used).max(0.0))
                    .sum();
                let redistrib = unused / n_hosts as f64;
                for host in self.hosts.values_mut() {
                    host.budget = per_host + redistrib;
                }
            }
        }

        self.last_rebalance = Utc::now();
    }

    /// Lift fleet halt if FDR has recovered.
    pub fn check_halt_status(&mut self) {
        if self.halted && self.compute_fleet_fdr() <= self.config.halt_threshold * 0.8 {
            self.halted = false;
            self.alerts.push(FdrAlert {
                kind: FdrAlertKind::HaltLifted,
                host_id: None,
                message: "Fleet FDR recovered; halt lifted".to_string(),
                timestamp: Utc::now(),
            });
        }
    }

    /// Get a summary of the current fleet FDR state.
    pub fn summary(&self) -> FleetFdrSummary {
        FleetFdrSummary {
            fleet_alpha: self.config.fleet_alpha,
            fleet_fdr: self.compute_fleet_fdr(),
            halted: self.halted,
            n_hosts: self.hosts.len(),
            total_tests: self.hosts.values().map(|h| h.n_tests).sum(),
            total_discoveries: self.hosts.values().map(|h| h.n_discoveries).sum(),
            quarantined_hosts: self
                .hosts
                .values()
                .filter(|h| h.quarantined)
                .map(|h| h.host_id.clone())
                .collect(),
        }
    }
}

/// Summary of fleet FDR state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FleetFdrSummary {
    pub fleet_alpha: f64,
    pub fleet_fdr: f64,
    pub halted: bool,
    pub n_hosts: usize,
    pub total_tests: u64,
    pub total_discoveries: u64,
    pub quarantined_hosts: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_register_and_allocate_equal() {
        let config = FleetFdrConfig {
            fleet_alpha: 0.06,
            allocation: AlphaAllocation::Equal,
            ..Default::default()
        };

        let mut coord = FleetFdrCoordinator::new(config);
        coord.register_host("host-1", 100);
        coord.register_host("host-2", 200);
        coord.register_host("host-3", 50);

        assert_eq!(coord.hosts.len(), 3);
        // Equal: 0.06 / 3 = 0.02 each
        for host in coord.hosts.values() {
            assert!((host.budget - 0.02).abs() < 1e-9);
        }
    }

    #[test]
    fn test_proportional_allocation() {
        let config = FleetFdrConfig {
            fleet_alpha: 0.05,
            allocation: AlphaAllocation::Proportional,
            ..Default::default()
        };

        let mut coord = FleetFdrCoordinator::new(config);
        coord.register_host("big", 300);
        coord.register_host("small", 100);

        // big gets 300/400 * 0.05 = 0.0375
        // small gets 100/400 * 0.05 = 0.0125
        let big = &coord.hosts["big"];
        let small = &coord.hosts["small"];
        assert!((big.budget - 0.0375).abs() < 1e-6);
        assert!((small.budget - 0.0125).abs() < 1e-6);
    }

    #[test]
    fn test_submit_approved() {
        let config = FleetFdrConfig {
            fleet_alpha: 0.1,
            allocation: AlphaAllocation::Equal,
            ..Default::default()
        };

        let mut coord = FleetFdrCoordinator::new(config);
        coord.register_host("h1", 100);

        // e-value of 100 → p-value of 0.01, well within budget (0.1).
        let result = coord.submit_e_value("h1", 100.0);
        assert!(result.approved);
        assert!(result.remaining_budget > 0.0);
    }

    #[test]
    fn test_submit_rejected_budget() {
        let config = FleetFdrConfig {
            fleet_alpha: 0.001, // Very tight budget
            allocation: AlphaAllocation::Equal,
            ..Default::default()
        };

        let mut coord = FleetFdrCoordinator::new(config);
        coord.register_host("h1", 100);

        // e-value of 2 → p-value of 0.5, exceeds budget of 0.001.
        let result = coord.submit_e_value("h1", 2.0);
        assert!(!result.approved);
        assert!(result.rejection_reason.is_some());
    }

    #[test]
    fn test_fleet_halt() {
        let config = FleetFdrConfig {
            fleet_alpha: 0.05,
            halt_threshold: 0.05,
            allocation: AlphaAllocation::Equal,
            ..Default::default()
        };

        let mut coord = FleetFdrCoordinator::new(config);
        coord.register_host("h1", 100);

        // Force high FDR by manipulating host state directly.
        let host = coord.hosts.get_mut("h1").unwrap();
        host.budget = 1.0; // Large budget to allow submission.
        host.used = 0.10;
        host.n_discoveries = 1; // After next: used=0.11, disc=2, FDR=0.055 > 0.05

        // Submit should trigger halt.
        let result = coord.submit_e_value("h1", 100.0);
        assert!(result.approved);
        assert!(coord.halted);

        // Next submission should be rejected.
        let result2 = coord.submit_e_value("h1", 100.0);
        assert!(!result2.approved);
        assert!(result2.rejection_reason.unwrap().contains("halt"));
    }

    #[test]
    fn test_pool_evidence() {
        let coord = FleetFdrCoordinator::new(FleetFdrConfig::default());

        let evidence = coord.pool_evidence("pattern_123", &[("h1", 5.0), ("h2", 3.0), ("h3", 4.0)]);

        assert_eq!(evidence.n_hosts, 3);
        assert!((evidence.combined_e_value - 60.0).abs() < 1e-6); // 5*3*4
        assert!(evidence.combined_e_value > 5.0); // Stronger than any individual
    }

    #[test]
    fn test_host_quarantine() {
        let config = FleetFdrConfig {
            fleet_alpha: 1.0, // Large budget
            host_quarantine_threshold: 0.10,
            halt_threshold: 1.0, // Won't halt
            allocation: AlphaAllocation::Equal,
            ..Default::default()
        };

        let mut coord = FleetFdrCoordinator::new(config);
        coord.register_host("h1", 100);

        // Manually set high local FDR.
        let host = coord.hosts.get_mut("h1").unwrap();
        host.budget = 1.0;
        host.used = 0.5;
        host.n_discoveries = 4; // FDR = 0.5/4 = 0.125 > 0.10

        // Next submission should trigger quarantine.
        coord.submit_e_value("h1", 100.0);
        assert!(coord.hosts["h1"].quarantined);

        // Quarantined host should be rejected.
        let result = coord.submit_e_value("h1", 1000.0);
        assert!(!result.approved);
    }

    #[test]
    fn test_summary() {
        let mut coord = FleetFdrCoordinator::new(FleetFdrConfig::default());
        coord.register_host("h1", 50);
        coord.register_host("h2", 100);

        let summary = coord.summary();
        assert_eq!(summary.n_hosts, 2);
        assert_eq!(summary.total_tests, 0);
        assert!(!summary.halted);
    }

    #[test]
    fn test_unregistered_host() {
        let mut coord = FleetFdrCoordinator::new(FleetFdrConfig::default());
        let result = coord.submit_e_value("unknown", 10.0);
        assert!(!result.approved);
        assert!(result.rejection_reason.unwrap().contains("not registered"));
    }
}
